{"ast":null,"code":"var _defineProperty = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require('lodash');\n\nvar _require = require('./utils'),\n    columnToLetter = _require.columnToLetter;\n\nvar _require2 = require('./errors'),\n    GoogleSpreadsheetFormulaError = _require2.GoogleSpreadsheetFormulaError;\n\nvar GoogleSpreadsheetCell = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function GoogleSpreadsheetCell(parentSheet, rowIndex, columnIndex, cellData) {\n    _classCallCheck(this, GoogleSpreadsheetCell);\n\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n\n    this._row = rowIndex;\n    this._column = columnIndex;\n\n    this._updateRawData(cellData);\n\n    return this;\n  } // newData can be undefined/null if the cell is totally empty and unformatted\n\n\n  _createClass(GoogleSpreadsheetCell, [{\n    key: \"_updateRawData\",\n    value: function _updateRawData() {\n      var newData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._rawData = newData;\n      this._draftData = {}; // stuff to save\n\n      this._error = null;\n\n      if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n        this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n      }\n    } // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n\n  }, {\n    key: \"rowIndex\",\n    get: function get() {\n      return this._row;\n    }\n  }, {\n    key: \"columnIndex\",\n    get: function get() {\n      return this._column;\n    }\n  }, {\n    key: \"a1Column\",\n    get: function get() {\n      return columnToLetter(this._column + 1);\n    }\n  }, {\n    key: \"a1Row\",\n    get: function get() {\n      return this._row + 1;\n    } // a1 row numbers start at 1 instead of 0\n\n  }, {\n    key: \"a1Address\",\n    get: function get() {\n      return \"\".concat(this.a1Column).concat(this.a1Row);\n    } // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n      if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n      if (this._error) return this._error;\n      if (!this._rawData.effectiveValue) return null;\n      return _.values(this._rawData.effectiveValue)[0];\n    },\n    set: function set(newValue) {\n      if (_.isBoolean(newValue)) {\n        this._draftData.valueType = 'boolValue';\n      } else if (_.isString(newValue)) {\n        if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';else this._draftData.valueType = 'stringValue';\n      } else if (_.isFinite(newValue)) {\n        this._draftData.valueType = 'numberValue';\n      } else if (_.isNil(newValue)) {\n        // null or undefined\n        this._draftData.valueType = 'stringValue';\n        newValue = '';\n      } else {\n        throw new Error('Set value to boolean, string, or number');\n      }\n\n      this._draftData.value = newValue;\n    }\n  }, {\n    key: \"valueType\",\n    get: function get() {\n      // an error only happens with a formula\n      if (this._error) return 'errorValue';\n      if (!this._rawData.effectiveValue) return null;\n      return _.keys(this._rawData.effectiveValue)[0];\n    }\n  }, {\n    key: \"formattedValue\",\n    get: function get() {\n      return this._rawData.formattedValue || null;\n    },\n    set: function set(newVal) {\n      throw new Error('You cannot modify the formatted value directly');\n    }\n  }, {\n    key: \"formula\",\n    get: function get() {\n      return _.get(this._rawData, 'userEnteredValue.formulaValue', null);\n    },\n    set: function set(newValue) {\n      if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n      this.value = newValue; // use existing value setter\n    }\n  }, {\n    key: \"formulaError\",\n    get: function get() {\n      return this._error;\n    }\n  }, {\n    key: \"hyperlink\",\n    get: function get() {\n      if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n      return this._rawData.hyperlink;\n    },\n    set: function set(val) {\n      throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n    }\n  }, {\n    key: \"note\",\n    get: function get() {\n      return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n    },\n    set: function set(newVal) {\n      if (newVal === null || newVal === undefined) newVal = '';\n      if (!_.isString(newVal)) throw new Error('Note must be a string');\n      if (newVal === this._rawData.note) delete this._draftData.note;else this._draftData.note = newVal;\n    } // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n\n  }, {\n    key: \"userEnteredFormat\",\n    get: function get() {\n      return this._rawData.userEnteredFormat;\n    },\n    set: function set(newVal) {\n      throw new Error('Do not modify directly, instead use format properties');\n    }\n  }, {\n    key: \"effectiveFormat\",\n    get: function get() {\n      return this._rawData.effectiveFormat;\n    },\n    set: function set(newVal) {\n      throw new Error('Read-only');\n    }\n  }, {\n    key: \"_getFormatParam\",\n    value: function _getFormatParam(param) {\n      // we freeze the object so users don't change nested props accidentally\n      // TODO: figure out something that would throw an error if you try to update it?\n      if (_.get(this._draftData, \"userEnteredFormat.\".concat(param))) {\n        throw new Error('User format is unsaved - save the cell to be able to read it again');\n      }\n\n      return Object.freeze(this._rawData.userEnteredFormat[param]);\n    }\n  }, {\n    key: \"_setFormatParam\",\n    value: function _setFormatParam(param, newVal) {\n      if (_.isEqual(newVal, _.get(this._rawData, \"userEnteredFormat.\".concat(param)))) {\n        _.unset(this._draftData, \"userEnteredFormat.\".concat(param));\n      } else {\n        _.set(this._draftData, \"userEnteredFormat.\".concat(param), newVal);\n\n        this._draftData.clearFormat = false;\n      }\n    } // format getters\n\n  }, {\n    key: \"numberFormat\",\n    get: function get() {\n      return this._getFormatParam('numberFormat');\n    },\n    set: // format setters\n    function set(newVal) {\n      return this._setFormatParam('numberFormat', newVal);\n    }\n  }, {\n    key: \"backgroundColor\",\n    get: function get() {\n      return this._getFormatParam('backgroundColor');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('backgroundColor', newVal);\n    }\n  }, {\n    key: \"borders\",\n    get: function get() {\n      return this._getFormatParam('borders');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('borders', newVal);\n    }\n  }, {\n    key: \"padding\",\n    get: function get() {\n      return this._getFormatParam('padding');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('padding', newVal);\n    }\n  }, {\n    key: \"horizontalAlignment\",\n    get: function get() {\n      return this._getFormatParam('horizontalAlignment');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('horizontalAlignment', newVal);\n    }\n  }, {\n    key: \"verticalAlignment\",\n    get: function get() {\n      return this._getFormatParam('verticalAlignment');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('verticalAlignment', newVal);\n    }\n  }, {\n    key: \"wrapStrategy\",\n    get: function get() {\n      return this._getFormatParam('wrapStrategy');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('wrapStrategy', newVal);\n    }\n  }, {\n    key: \"textDirection\",\n    get: function get() {\n      return this._getFormatParam('textDirection');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('textDirection', newVal);\n    }\n  }, {\n    key: \"textFormat\",\n    get: function get() {\n      return this._getFormatParam('textFormat');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('textFormat', newVal);\n    }\n  }, {\n    key: \"hyperlinkDisplayType\",\n    get: function get() {\n      return this._getFormatParam('hyperlinkDisplayType');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('hyperlinkDisplayType', newVal);\n    }\n  }, {\n    key: \"textRotation\",\n    get: function get() {\n      return this._getFormatParam('textRotation');\n    },\n    set: function set(newVal) {\n      return this._setFormatParam('textRotation', newVal);\n    }\n  }, {\n    key: \"clearAllFormatting\",\n    value: function clearAllFormatting() {\n      // need to track this separately since by setting/unsetting things, we may end up with\n      // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n      this._draftData.clearFormat = true;\n      delete this._draftData.userEnteredFormat;\n    } // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n    // returns true if there are any updates that have not been saved yet\n\n  }, {\n    key: \"_isDirty\",\n    get: function get() {\n      // have to be careful about checking undefined rather than falsy\n      // in case a new value is empty string or 0 or false\n      if (this._draftData.note !== undefined) return true;\n      if (_.keys(this._draftData.userEnteredFormat).length) return true;\n      if (this._draftData.clearFormat) return true;\n      if (this._draftData.value !== undefined) return true;\n      return false;\n    }\n  }, {\n    key: \"discardUnsavedChanges\",\n    value: function discardUnsavedChanges() {\n      this._draftData = {};\n    }\n  }, {\n    key: \"save\",\n    value: function () {\n      var _save = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._sheet.saveUpdatedCells([this]);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function save() {\n        return _save.apply(this, arguments);\n      }\n\n      return save;\n    }() // used by worksheet when saving cells\n    // returns an individual batchUpdate request to update the cell\n\n  }, {\n    key: \"_getUpdateRequest\",\n    value: function _getUpdateRequest() {\n      // this logic should match the _isDirty logic above\n      // but we need it broken up to build the request below\n      var isValueUpdated = this._draftData.value !== undefined;\n      var isNoteUpdated = this._draftData.note !== undefined;\n      var isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n      var isFormatCleared = this._draftData.clearFormat; // if no updates, we return null, which we can filter out later before sending requests\n\n      if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n        return null;\n      } // build up the formatting object, which has some quirks...\n\n\n      var format = _objectSpread(_objectSpread({}, this._rawData.userEnteredFormat), this._draftData.userEnteredFormat); // if background color already set, cell has backgroundColor and backgroundColorStyle\n      // but backgroundColorStyle takes precendence so we must remove to set the color\n      // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n\n\n      if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n        delete format.backgroundColorStyle;\n      }\n\n      return {\n        updateCells: {\n          rows: [{\n            values: [_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, isValueUpdated && {\n              userEnteredValue: _defineProperty({}, this._draftData.valueType, this._draftData.value)\n            }), isNoteUpdated && {\n              note: this._draftData.note\n            }), isFormatUpdated && {\n              userEnteredFormat: format\n            }), isFormatCleared && {\n              userEnteredFormat: {}\n            })]\n          }],\n          // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n          fields: _.keys(_.pickBy({\n            userEnteredValue: isValueUpdated,\n            note: isNoteUpdated,\n            userEnteredFormat: isFormatUpdated || isFormatCleared\n          })).join(','),\n          start: {\n            sheetId: this._sheet.sheetId,\n            rowIndex: this.rowIndex,\n            columnIndex: this.columnIndex\n          }\n        }\n      };\n    }\n  }]);\n\n  return GoogleSpreadsheetCell;\n}();\n\nmodule.exports = GoogleSpreadsheetCell;","map":{"version":3,"sources":["C:/Users/91808/Music/onlineitsoftwaresolutions/node_modules/google-spreadsheet/lib/GoogleSpreadsheetCell.js"],"names":["_","require","columnToLetter","GoogleSpreadsheetFormulaError","GoogleSpreadsheetCell","parentSheet","rowIndex","columnIndex","cellData","_sheet","_row","_column","_updateRawData","newData","_rawData","_draftData","_error","get","effectiveValue","errorValue","a1Column","a1Row","value","undefined","Error","values","newValue","isBoolean","valueType","isString","substr","isFinite","isNil","keys","formattedValue","newVal","hyperlink","val","note","userEnteredFormat","effectiveFormat","param","Object","freeze","isEqual","unset","set","clearFormat","_getFormatParam","_setFormatParam","length","saveUpdatedCells","isValueUpdated","isNoteUpdated","isFormatUpdated","isFormatCleared","some","format","backgroundColorStyle","updateCells","rows","userEnteredValue","fields","pickBy","join","start","sheetId","module","exports"],"mappings":"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","sourcesContent":["const _ = require('lodash');\n\nconst { columnToLetter } = require('./utils');\n\nconst { GoogleSpreadsheetFormulaError } = require('./errors');\n\nclass GoogleSpreadsheetCell {\n  constructor(parentSheet, rowIndex, columnIndex, cellData) {\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n    this._row = rowIndex;\n    this._column = columnIndex;\n\n    this._updateRawData(cellData);\n    return this;\n  }\n\n  // newData can be undefined/null if the cell is totally empty and unformatted\n  _updateRawData(newData = {}) {\n    this._rawData = newData;\n    this._draftData = {}; // stuff to save\n    this._error = null;\n    if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n      this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n    }\n  }\n\n  // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n  get rowIndex() { return this._row; }\n  get columnIndex() { return this._column; }\n  get a1Column() { return columnToLetter(this._column + 1); }\n  get a1Row() { return this._row + 1; } // a1 row numbers start at 1 instead of 0\n  get a1Address() { return `${this.a1Column}${this.a1Row}`; }\n\n  // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n  get value() {\n    // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n    if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n    if (this._error) return this._error;\n    if (!this._rawData.effectiveValue) return null;\n    return _.values(this._rawData.effectiveValue)[0];\n  }\n\n  set value(newValue) {\n    if (_.isBoolean(newValue)) {\n      this._draftData.valueType = 'boolValue';\n    } else if (_.isString(newValue)) {\n      if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';\n      else this._draftData.valueType = 'stringValue';\n    } else if (_.isFinite(newValue)) {\n      this._draftData.valueType = 'numberValue';\n    } else if (_.isNil(newValue)) {\n      // null or undefined\n      this._draftData.valueType = 'stringValue';\n      newValue = '';\n    } else {\n      throw new Error('Set value to boolean, string, or number');\n    }\n    this._draftData.value = newValue;\n  }\n\n  get valueType() {\n    // an error only happens with a formula\n    if (this._error) return 'errorValue';\n    if (!this._rawData.effectiveValue) return null;\n    return _.keys(this._rawData.effectiveValue)[0];\n  }\n\n  get formattedValue() { return this._rawData.formattedValue || null; }\n  set formattedValue(newVal) {\n    throw new Error('You cannot modify the formatted value directly');\n  }\n\n  get formula() { return _.get(this._rawData, 'userEnteredValue.formulaValue', null); }\n  set formula(newValue) {\n    if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n    this.value = newValue; // use existing value setter\n  }\n  get formulaError() { return this._error; }\n\n  get hyperlink() {\n    if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n    return this._rawData.hyperlink;\n  }\n  set hyperlink(val) {\n    throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n  }\n\n  get note() {\n    return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n  }\n\n  set note(newVal) {\n    if (newVal === null || newVal === undefined) newVal = '';\n    if (!_.isString(newVal)) throw new Error('Note must be a string');\n    if (newVal === this._rawData.note) delete this._draftData.note;\n    else this._draftData.note = newVal;\n  }\n\n  // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n  get userEnteredFormat() { return this._rawData.userEnteredFormat; }\n  get effectiveFormat() { return this._rawData.effectiveFormat; }\n  set userEnteredFormat(newVal) { throw new Error('Do not modify directly, instead use format properties'); }\n  set effectiveFormat(newVal) { throw new Error('Read-only'); }\n\n  _getFormatParam(param) {\n    // we freeze the object so users don't change nested props accidentally\n    // TODO: figure out something that would throw an error if you try to update it?\n    if (_.get(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error('User format is unsaved - save the cell to be able to read it again');\n    }\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n\n  _setFormatParam(param, newVal) {\n    if (_.isEqual(newVal, _.get(this._rawData, `userEnteredFormat.${param}`))) {\n      _.unset(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      _.set(this._draftData, `userEnteredFormat.${param}`, newVal);\n      this._draftData.clearFormat = false;\n    }\n  }\n\n  // format getters\n  get numberFormat() { return this._getFormatParam('numberFormat'); }\n  get backgroundColor() { return this._getFormatParam('backgroundColor'); }\n  get borders() { return this._getFormatParam('borders'); }\n  get padding() { return this._getFormatParam('padding'); }\n  get horizontalAlignment() { return this._getFormatParam('horizontalAlignment'); }\n  get verticalAlignment() { return this._getFormatParam('verticalAlignment'); }\n  get wrapStrategy() { return this._getFormatParam('wrapStrategy'); }\n  get textDirection() { return this._getFormatParam('textDirection'); }\n  get textFormat() { return this._getFormatParam('textFormat'); }\n  get hyperlinkDisplayType() { return this._getFormatParam('hyperlinkDisplayType'); }\n  get textRotation() { return this._getFormatParam('textRotation'); }\n\n  // format setters\n  set numberFormat(newVal) { return this._setFormatParam('numberFormat', newVal); }\n  set backgroundColor(newVal) { return this._setFormatParam('backgroundColor', newVal); }\n  set borders(newVal) { return this._setFormatParam('borders', newVal); }\n  set padding(newVal) { return this._setFormatParam('padding', newVal); }\n  set horizontalAlignment(newVal) { return this._setFormatParam('horizontalAlignment', newVal); }\n  set verticalAlignment(newVal) { return this._setFormatParam('verticalAlignment', newVal); }\n  set wrapStrategy(newVal) { return this._setFormatParam('wrapStrategy', newVal); }\n  set textDirection(newVal) { return this._setFormatParam('textDirection', newVal); }\n  set textFormat(newVal) { return this._setFormatParam('textFormat', newVal); }\n  set hyperlinkDisplayType(newVal) { return this._setFormatParam('hyperlinkDisplayType', newVal); }\n  set textRotation(newVal) { return this._setFormatParam('textRotation', newVal); }\n\n  clearAllFormatting() {\n    // need to track this separately since by setting/unsetting things, we may end up with\n    // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  }\n\n  // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n\n  // returns true if there are any updates that have not been saved yet\n  get _isDirty() {\n    // have to be careful about checking undefined rather than falsy\n    // in case a new value is empty string or 0 or false\n    if (this._draftData.note !== undefined) return true;\n    if (_.keys(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== undefined) return true;\n    return false;\n  }\n\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n\n  async save() {\n    await this._sheet.saveUpdatedCells([this]);\n  }\n\n  // used by worksheet when saving cells\n  // returns an individual batchUpdate request to update the cell\n  _getUpdateRequest() {\n    // this logic should match the _isDirty logic above\n    // but we need it broken up to build the request below\n    const isValueUpdated = this._draftData.value !== undefined;\n    const isNoteUpdated = this._draftData.note !== undefined;\n    const isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat;\n\n    // if no updates, we return null, which we can filter out later before sending requests\n    if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    }\n\n    // build up the formatting object, which has some quirks...\n    const format = {\n      // have to pass the whole object or it will clear existing properties\n      ...this._rawData.userEnteredFormat,\n      ...this._draftData.userEnteredFormat,\n    };\n    // if background color already set, cell has backgroundColor and backgroundColorStyle\n    // but backgroundColorStyle takes precendence so we must remove to set the color\n    // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n    if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n      delete (format.backgroundColorStyle);\n    }\n\n\n    return {\n      updateCells: {\n        rows: [{\n          values: [{\n            ...isValueUpdated && {\n              userEnteredValue: { [this._draftData.valueType]: this._draftData.value },\n            },\n            ...isNoteUpdated && {\n              note: this._draftData.note,\n            },\n            ...isFormatUpdated && {\n              userEnteredFormat: format,\n            },\n            ...isFormatCleared && {\n              userEnteredFormat: {},\n            },\n          }],\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: _.keys(_.pickBy({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared,\n        })).join(','),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex,\n        },\n      },\n    };\n  }\n}\n\nmodule.exports = GoogleSpreadsheetCell;\n"]},"metadata":{},"sourceType":"script"}